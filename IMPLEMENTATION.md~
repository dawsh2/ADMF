# ADMF Implementation Guide

This guide provides a pragmatic approach to implementing the ADMF trading system, with specific steps to avoid common pitfalls and establish a working system quickly.

## Implementation Philosophy

Based on our discussions and the project goals, we're taking an **incremental, working-first approach** with these key principles:

1. **Start with minimal working code** that demonstrates complete functionality
2. **Maintain event-driven architecture** from the beginning to prevent lookahead bias
3. **Refactor incrementally** from simple to complex architecture
4. **Test each step** to maintain a working system throughout development
5. **Use passthrough modes** to simplify complex components when needed

## Phased Implementation Plan

This implementation plan is designed to deliver value at each phase while building toward a complete architecture.

### Phase 1: Minimal Working System

**Goal**: Create a single-file, event-driven backtest system that works end-to-end.

1. **Create `main.py`**: Implement a simple but complete event-driven backtest system
   - Include minimal event system, MA crossover strategy, simple portfolio and broker

2. **Features to include**:
   - Event-driven architecture (BAR → SIGNAL → ORDER → FILL) to prevent lookahead bias
   - Moving average crossover strategy calculation
   - Portfolio tracking with position updates
   - End-to-end functionality with equity curve output

3. **Key components in this file**:
   - `MinimalEventSystem`: Simple publish/subscribe mechanism
   - `SimpleBacktester`: Orchestrates the process and loads data
   - `SimpleMAStrategy`: Calculates moving averages and generates signals
   - `SimpleBroker`: Executes orders with basic fill logic
   - `SimplePortfolio`: Tracks positions and equity

This creates a foundation that works correctly and maintains event-driven integrity.

### Phase 2: Core Module Extraction

**Goal**: Extract the core module while maintaining a working system.

1. **Extract event system**:
   ```
   src/core/events/
   ├── __init__.py
   ├── event_bus.py           # Extract from MinimalEventSystem
   └── event_types.py         # Define standard event types
   ```

2. **Extract component base class**:
   ```
   src/core/component/
   ├── __init__.py
   └── component.py           # Base component with lifecycle methods
   ```

3. **Extract configuration system**:
   ```
   src/core/config/
   ├── __init__.py
   └── config.py              # YAML/JSON configuration loading
   ```

4. **Implement context management**:
   ```python
   class Context:
       def __init__(self):
           self._items = {}
           
       def register(self, name, item):
           self._items[name] = item
           
       def get(self, name, default=None):
           return self._items.get(name, default)
   ```

5. **Update `main.py` to use these components**

### Phase 3: Strategy Module Extraction

**Goal**: Extract strategies while adding parameter management.

1. **Extract strategy base class**:
   ```
   src/strategy/base/
   ├── __init__.py
   └── strategy.py            # Strategy base class
   ```

2. **Extract MA crossover strategy**:
   ```
   src/strategy/implementations/
   ├── __init__.py
   └── ma_crossover.py        # MA strategy with parameters
   ```

3. **Add parameter management**:
   ```
   src/strategy/parameters/
   ├── __init__.py
   └── parameter_set.py       # Parameter validation and access
   ```

4. **Implement strategy factory**:
   ```
   src/strategy/factory.py    # Create strategies from configuration
   ```

### Phase 4: Data Module Implementation

**Goal**: Implement proper data handling with train/test splitting.

1. **Extract data handler**:
   ```
   src/data/handlers/
   ├── __init__.py
   └── historical_data_handler.py  # CSV data loading
   ```

2. **Implement train/test splitter**:
   ```
   src/data/splitters/
   ├── __init__.py
   └── train_test_splitter.py  # Data splitting with isolation
   ```

3. **Add data models**:
   ```
   src/data/models/
   ├── __init__.py
   └── bar.py                  # Standardized bar model
   ```

4. **Update main loop to support data splitting**

### Phase 5: Risk and Execution Module Implementation

**Goal**: Extract risk management and order execution.

1. **Extract risk manager**:
   ```
   src/risk/managers/
   ├── __init__.py
   └── risk_manager.py         # Signal to order conversion
   ```

2. **Extract position sizing**:
   ```
   src/risk/sizers/
   ├── __init__.py
   ├── fixed_sizer.py          # Fixed quantity sizing
   └── percent_equity_sizer.py # Percentage of equity sizing
   ```

3. **Extract portfolio manager**:
   ```
   src/risk/portfolio/
   ├── __init__.py
   └── portfolio.py            # Position and equity tracking
   ```

4. **Extract broker and execution**:
   ```
   src/execution/broker/
   ├── __init__.py
   └── simulated_broker.py     # Order execution simulation
   ```

5. **Extract order management**:
   ```
   src/execution/order/
   ├── __init__.py
   └── order_manager.py        # Order tracking and lifecycle
   ```

### Phase 6: Optimization Framework

**Goal**: Implement grid search optimization with train/test validation.

1. **Implement parameter space**:
   ```
   src/strategy/optimization/
   ├── __init__.py
   └── parameter_space.py      # Define search space
   ```

2. **Implement grid search**:
   ```
   src/strategy/optimization/
   └── grid_search.py          # Grid search implementation
   ```

3. **Add train/test validation**:
   ```python
   def optimize_strategy(parameter_space, data_handler):
       """Run optimization with train/test validation."""
       best_params = None
       best_test_performance = float('-inf')
       
       # Set up train/test split
       data_handler.setup_train_test_split(train_ratio=0.7)
       
       # Iterate through parameters
       for params in parameter_space.get_combinations():
           # Evaluate on training data
           data_handler.set_active_split('train')
           train_result = run_backtest(params)
           
           # Evaluate on test data
           data_handler.set_active_split('test')
           test_result = run_backtest(params)
           
           # Track best parameters based on test performance
           if test_result['sharpe_ratio'] > best_test_performance:
               best_params = params
               best_test_performance = test_result['sharpe_ratio']
               
       return best_params, best_test_performance
   ```

4. **Add optimization runner**:
   ```
   src/optimization_runner.py  # Main script for optimization
   ```

### Phase 7: Analytics and Reporting

**Goal**: Add performance analytics and reporting.

1. **Implement analytics framework**:
   ```
   src/core/analytics/
   ├── __init__.py
   ├── metrics/
   │   ├── __init__.py
   │   ├── returns.py          # Return-based metrics
   │   └── risk.py             # Risk metrics
   └── reporting/
       ├── __init__.py
       └── report_generator.py # Performance report generation
   ```

2. **Add visualization**:
   ```
   src/core/analytics/visualization/
   ├── __init__.py
   └── charts.py               # Chart generation
   ```

3. **Integrate analytics with backtest results**

## Advanced Strategy Implementation

Once the base system is working, implement the more complex ensemble strategy framework:

### Phase 8: Ensemble Strategy Framework

1. **Implement composite strategy**:
   ```
   src/strategy/composite/
   ├── __init__.py
   └── composite_strategy.py   # Strategy composition
   ```

2. **Implement regime detector**:
   ```
   src/strategy/regime/
   ├── __init__.py
   ├── regime_detector.py      # Market regime detection
   └── regime_strategy.py      # Regime-specific strategy
   ```

3. **Add weighted signal aggregation**:
   ```
   src/strategy/composite/
   └── signal_aggregator.py    # Weight and combine signals
   ```

## Starting with Complex Strategy First?

You asked whether you should start with a more complex strategy implementation first. Here's my recommendation:

### When to Start with a Complex Strategy

Starting with a complex strategy like a regime-filtered ensemble can be beneficial if:

1. **The strategy is well-defined**: You already have a clear implementation in mind
2. **It's the core value proposition**: The regime filtering is the main feature you're building for
3. **You want to test architecture limits**: Complex strategies expose architectural weaknesses early

### Recommended Approach

If you decide to start with a complex strategy:

1. **Still begin with a minimal working system**: Create a simplified version of the complex strategy that works end-to-end
2. **Use passthrough modes extensively**: Implement simplified versions of components at first
3. **Focus on the essential logic**: Implement the core regime detection and strategy switching first
4. **Add sophistication incrementally**: Start with simple rules for regime detection, then add complexity

For example, you could start with:
```python
class SimpleRegimeStrategy:
    def __init__(self):
        self.strategies = {
            'trending': MAStrategy(fast=10, slow=30),
            'ranging': MeanReversionStrategy(window=20)
        }
        self.current_regime = None
        
    def on_bar(self, bar):
        # Simple regime detection
        self.current_regime = self._detect_regime(bar)
        
        # Use appropriate strategy
        active_strategy = self.strategies[self.current_regime]
        return active_strategy.on_bar(bar)
        
    def _detect_regime(self, bar):
        # Simple regime detection based on recent volatility
        # Replace with your actual regime detection logic
        return 'trending' if bar['volatility'] > 0.01 else 'ranging'
```

This simplified approach lets you test the core concept before implementing the full architecture.

## Practical Implementation Recommendations

### 1. Start with a Working Script

Begin with this simple script structure:

```python
# main.py - Simple but complete backtest system

import pandas as pd
import numpy as np
from datetime import datetime
from collections import deque

# 1. Minimal Event System
class EventSystem:
    def __init__(self):
        self.handlers = {}
        
    def subscribe(self, event_type, handler):
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        self.handlers[event_type].append(handler)
        
    def emit(self, event_type, data):
        if event_type not in self.handlers:
            return
        for handler in self.handlers[event_type]:
            handler(data)

# 2. Simple Components
class MAStrategy:
    def __init__(self, events, fast_window=10, slow_window=30):
        self.events = events
        self.fast_window = fast_window
        self.slow_window = slow_window
        self.prices = []
        self.position = 0
        
    def on_bar(self, bar):
        # Store price
        self.prices.append(bar['close'])
        
        # Skip if not enough data
        if len(self.prices) < self.slow_window:
            return
            
        # Calculate MAs
        fast_ma = np.mean(self.prices[-self.fast_window:])
        slow_ma = np.mean(self.prices[-self.slow_window:])
        
        # Generate signals on crossover
        if fast_ma > slow_ma and self.position <= 0:
            signal = {
                'timestamp': bar['timestamp'],
                'symbol': bar['symbol'],
                'direction': 'BUY',
                'price': bar['close']
            }
            self.position = 1
            self.events.emit('SIGNAL', signal)
            
        elif fast_ma < slow_ma and self.position >= 0:
            signal = {
                'timestamp': bar['timestamp'],
                'symbol': bar['symbol'],
                'direction': 'SELL',
                'price': bar['close']
            }
            self.position = -1
            self.events.emit('SIGNAL', signal)

class Broker:
    def __init__(self, events):
        self.events = events
    
    def on_signal(self, signal):
        # Create order from signal
        order = signal.copy()
        order['quantity'] = 100  # Fixed size
        self.events.emit('ORDER', order)
        
        # Create fill (simplified execution)
        fill = order.copy()
        fill['fill_price'] = fill['price']
        self.events.emit('FILL', fill)

class Portfolio:
    def __init__(self, events, initial_cash=10000.0):
        self.events = events
        self.cash = initial_cash
        self.positions = {}
        self.equity_curve = []
        
    def on_fill(self, fill):
        # Update position
        symbol = fill['symbol']
        qty = fill['quantity'] if fill['direction'] == 'BUY' else -fill['quantity']
        price = fill['fill_price']
        
        # Update position
        if symbol not in self.positions:
            self.positions[symbol] = 0
        self.positions[symbol] += qty
        
        # Update cash
        self.cash -= qty * price
        
        # Calculate portfolio value
        portfolio_value = self.cash
        for sym, pos in self.positions.items():
            # Use fill price as current price (simplified)
            portfolio_value += pos * price
            
        # Update equity curve
        self.equity_curve.append({
            'timestamp': fill['timestamp'],
            'portfolio_value': portfolio_value
        })

# 3. Backtest Runner
def run_backtest(data_file, fast_window=10, slow_window=30):
    # Load data
    data = pd.read_csv(data_file)
    data['timestamp'] = pd.to_datetime(data['timestamp'])
    
    # Create event system
    events = EventSystem()
    
    # Create components
    strategy = MAStrategy(events, fast_window, slow_window)
    broker = Broker(events)
    portfolio = Portfolio(events)
    
    # Set up event subscriptions
    events.subscribe('BAR', strategy.on_bar)
    events.subscribe('SIGNAL', broker.on_signal)
    events.subscribe('FILL', portfolio.on_fill)
    
    # Process each bar
    for i in range(len(data)):
        bar = data.iloc[i].to_dict()
        bar['timestamp'] = data.iloc[i]['timestamp']
        events.emit('BAR', bar)
    
    # Calculate performance metrics
    equity = portfolio.equity_curve
    
    if len(equity) < 2:
        return {
            'total_return': 0,
            'sharpe_ratio': 0,
            'max_drawdown': 0
        }
    
    equity_values = [point['portfolio_value'] for point in equity]
    returns = [(equity_values[i] / equity_values[i-1]) - 1 for i in range(1, len(equity_values))]
    
    total_return = (equity_values[-1] / equity_values[0]) - 1
    sharpe_ratio = np.mean(returns) / np.std(returns) * np.sqrt(252) if len(returns) > 1 else 0
    
    # Calculate max drawdown
    peak = equity_values[0]
    max_drawdown = 0
    
    for value in equity_values:
        if value > peak:
            peak = value
        drawdown = (peak - value) / peak
        max_drawdown = max(max_drawdown, drawdown)
    
    return {
        'total_return': total_return,
        'sharpe_ratio': sharpe_ratio,
        'max_drawdown': max_drawdown,
        'equity_curve': equity
    }

# 4. Simple Optimization
def optimize_strategy(data_file, param_grid):
    """Simple grid search optimization."""
    best_params = None
    best_sharpe = float('-inf')
    
    # Split data for train/test (simple approach)
    data = pd.read_csv(data_file)
    split_idx = int(len(data) * 0.7)
    
    train_file = "train_data_temp.csv"
    test_file = "test_data_temp.csv"
    
    data.iloc[:split_idx].to_csv(train_file, index=False)
    data.iloc[split_idx:].to_csv(test_file, index=False)
    
    # Grid search on training data
    for fast_window in param_grid['fast_window']:
        for slow_window in param_grid['slow_window']:
            if fast_window >= slow_window:
                continue
                
            # Run backtest with these parameters
            result = run_backtest(train_file, fast_window, slow_window)
            
            # Update best parameters
            if result['sharpe_ratio'] > best_sharpe:
                best_sharpe = result['sharpe_ratio']
                best_params = {
                    'fast_window': fast_window,
                    'slow_window': slow_window
                }
    
    # Validate on test data
    if best_params:
        test_result = run_backtest(test_file, best_params['fast_window'], best_params['slow_window'])
        print(f"Test performance: {test_result}")
    
    # Clean up temporary files
    import os
    os.remove(train_file)
    os.remove(test_file)
    
    return best_params, best_sharpe

# 5. Main execution
if __name__ == "__main__":
    # Define parameter grid
    param_grid = {
        'fast_window': [5, 10, 15, 20],
        'slow_window': [20, 30, 40, 50]
    }
    
    # Run optimization
    best_params, best_sharpe = optimize_strategy('data/SPY_1min.csv', param_grid)
    
    print(f"Best parameters: {best_params}")
    print(f"Best Sharpe ratio: {best_sharpe:.4f}")
    
    # Run final backtest with best parameters
    final_result = run_backtest(
        'data/SPY_1min.csv', 
        best_params['fast_window'], 
        best_params['slow_window']
    )
    
    print(f"Final backtest results:")
    print(f"Total return: {final_result['total_return']:.4f}")
    print(f"Sharpe ratio: {final_result['sharpe_ratio']:.4f}")
    print(f"Max drawdown: {final_result['max_drawdown']:.4f}")
```

This script provides a complete, working backtest system in one file while maintaining event-driven architecture to prevent lookahead bias.

### 2. Refactor Incrementally

After the initial script works:

1. **Extract one component at a time** (event system first, then strategy, etc.)
2. **Test after each extraction** to ensure the system still works
3. **Move toward the target architecture** gradually

### 3. Add Validation Early

Add these validation mechanisms early in the process:

1. **Event flow validation**: Verify events are properly sequenced
2. **State reset validation**: Verify components properly reset between runs
3. **Data isolation checks**: Verify train/test data doesn't leak

### 4. Use Simple Config Files

Start with simple YAML configuration:

```yaml
# config/backtest.yaml
data:
  file: "data/SPY_1min.csv"
  symbol: "SPY"
  
strategy:
  name: "MovingAverageCrossover"
  parameters:
    fast_window: 10
    slow_window: 30
    
risk:
  position_size: 100
  max_exposure: 0.5
  
execution:
  commission: 0.0
  slippage: 0.0001
  
optimization:
  parameter_space:
    fast_window:
      min: 5
      max: 50
      step: 5
    slow_window:
      min: 20
      max: 100
      step: 10
```

## Handling Implementation Challenges

### 1. Data Leakage Prevention

To prevent lookahead bias:

1. **Process bars sequentially** through the event system
2. **Maintain strict isolation** between train and test data
3. **Implement context boundaries** for optimization runs
4. **Reset component state** completely between runs

### 2. Performance Optimization

To improve performance:

1. **Use passthrough modes** for development and debugging
2. **Add caching** for expensive calculations
3. **Use numpy** for vectorized operations when possible
4. **Profile regular**ly to identify bottlenecks

### 3. Testing Strategy

To ensure reliable implementation:

1. **Unit test core components** (event system, data isolation)
2. **Create simple test cases** with known outcomes
3. **Compare results** with simple implementations

## Complex Strategy Implementation Guide

Once the base system is working, you can implement more complex strategies:

### Regime-Filtered Ensemble Strategy

```python
class RegimeDetector:
    def __init__(self, window=50):
        self.window = window
        self.prices = []
        
    def detect_regime(self, bar):
        """Detect market regime based on recent price action."""
        self.prices.append(bar['close'])
        if len(self.prices) < self.window:
            return 'unknown'
            
        # Calculate indicators
        returns = np.diff(self.prices[-self.window:]) / self.prices[-self.window:-1]
        volatility = np.std(returns) * np.sqrt(252)
        trend = self.prices[-1] / np.mean(self.prices[-self.window:]) - 1
        
        # Determine regime
        if volatility > 0.2:  # High volatility
            return 'volatile'
        elif abs(trend) > 0.05:  # Strong trend
            return 'trending' if trend > 0 else 'downtrend'
        else:  # Range-bound
            return 'ranging'

class EnsembleStrategy:
    def __init__(self, events):
        self.events = events
        self.regime_detector = RegimeDetector()
        self.strategies = {
            'trending': MAStrategy(events, 10, 30),
            'downtrend': MAStrategy(events, 5, 20),
            'ranging': MeanReversionStrategy(events, 20),
            'volatile': BreakoutStrategy(events, 10),
            'unknown': MAStrategy(events, 10, 30)  # Default strategy
        }
        self.current_regime = 'unknown'
        
    def on_bar(self, bar):
        # Detect regime
        self.current_regime = self.regime_detector.detect_regime(bar)
        
        # Use appropriate strategy
        active_strategy = self.strategies[self.current_regime]
        active_strategy.on_bar(bar)
```

### Weighted Signal Combination

```python
class WeightedEnsembleStrategy:
    def __init__(self, events):
        self.events = events
        self.strategies = [
            {'strategy': MAStrategy(events, 10, 30), 'weight': 0.4},
            {'strategy': MeanReversionStrategy(events, 20), 'weight': 0.3},
            {'strategy': BreakoutStrategy(events, 10), 'weight': 0.3}
        ]
        self.signals = []
        
    def on_bar(self, bar):
        # Collect signals from all strategies
        all_signals = []
        for strategy_info in self.strategies:
            strategy = strategy_info['strategy']
            weight = strategy_info['weight']
            
            # Get signal (directly calling to avoid event emission)
            signal = strategy._calculate_signal(bar)
            if signal:
                signal['weight'] = weight
                all_signals.append(signal)
                
        # Aggregate signals
        if all_signals:
            aggregated_signal = self._aggregate_signals(all_signals, bar)
            if aggregated_signal:
                # Only emit the aggregated signal
                self.events.emit('SIGNAL', aggregated_signal)
                
    def _aggregate_signals(self, signals, bar):
        """Aggregate signals based on weights."""
        # Calculate weighted sum of signal strengths
        buy_strength = sum(s['weight'] for s in signals if s['direction'] == 'BUY')
        sell_strength = sum(s['weight'] for s in signals if s['direction'] == 'SELL')
        
        # Generate signal if strength exceeds threshold
        direction = None
        if buy_strength > 0.6:
            direction = 'BUY'
        elif sell_strength > 0.6:
            direction = 'SELL'
            
        if direction:
            return {
                'timestamp': bar['timestamp'],
                'symbol': bar['symbol'],
                'direction': direction,
                'price': bar['close'],
                'strength': buy_strength if direction == 'BUY' else sell_strength
            }
        return None
```

## Conclusion

This implementation guide provides a pragmatic approach to building the ADMF trading system, starting with a minimal working system and refactoring toward a complete architecture. By following this approach, you can:

1. Have a working system at every stage of development
2. Maintain proper event-driven architecture to prevent lookahead bias
3. Add architectural complexity only as needed
4. Implement advanced features like ensemble strategies in a structured way

The key is to start simple, get something working, and incrementally improve while always maintaining a functioning system.