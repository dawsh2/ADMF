# main.py
import argparse
import logging
import sys # For sys.exit

from src.core.config import SimpleConfigLoader
from src.core.logging_setup import setup_logging
from src.core.exceptions import ConfigurationError, ADMFTraderError

# It's good practice to get a logger for your main application module
logger = logging.getLogger(__name__)

def main():
    """
    Main function to bootstrap and run the ADMF-Trader application.
    """
    # 1. Parse Command-Line Arguments
    parser = argparse.ArgumentParser(description="ADMF-Trader Application")
    parser.add_argument(
        "--config",
        type=str,
        default="config/config.yaml", # Default config path
        help="Path to the configuration YAML file."
    )
    args = parser.parse_args()

    config_path = args.config
    config_loader = None

    try:
        # 2. Initialize Configuration
        logger.info(f"Attempting to load configuration from: {config_path}")
        config_loader = SimpleConfigLoader(config_file_path=config_path)
        logger.info("Configuration loaded successfully.")

        # 3. Setup Logging (using the loaded configuration)
        # Note: The logger instance used above this point will use Python's default
        # basicConfig if setup_logging hasn't run. After setup_logging, all
        # loggers will adhere to the new configuration.
        setup_logging(config_loader)
        logger.info("Logging system initialized and configured.")
        logger.info(f"Application Name from config: {config_loader.get('system.name', 'N/A')}")


        # --- Placeholder for future application logic ---
        logger.info("Bootstrap complete. ADMF-Trader MVP is starting...")
        # In the future, you would initialize and run your main application
        # components here, e.g., BacktestCoordinator, services, etc.
        # For Phase 1 MVP, we might just log that it started.

        run_application_logic(config_loader)

        logger.info("ADMF-Trader MVP finished.")
        # --- End placeholder ---

    except ConfigurationError as e:
        # If logging wasn't set up due to config error, this logger might not be fully configured.
        # However, SimpleConfigLoader already logs critically.
        logger.critical(f"CRITICAL ERROR during bootstrap: Configuration error - {e}")
        print(f"CRITICAL: Configuration error - {e}. Please check the logs and config file: {config_path}", file=sys.stderr)
        sys.exit(1) # Exit with an error code
    except ADMFTraderError as e: # Catch other application-specific errors
        logger.critical(f"CRITICAL ERROR during bootstrap: {e}")
        print(f"CRITICAL: Application error - {e}. Please check the logs.", file=sys.stderr)
        sys.exit(1)
    except Exception as e: # Catch any other unexpected errors
        logger.critical(f"UNEXPECTED CRITICAL ERROR during bootstrap: {e}", exc_info=True)
        print(f"CRITICAL: Unexpected error - {e}. Please check the logs.", file=sys.stderr)
        sys.exit(1)


def run_application_logic(config_loader):
    """
    Placeholder for the main application logic.
    For MVP, this could be very simple.
    """
    logger.info("Running main application logic...")
    # Example: Accessing config within the application
    data_file = config_loader.get("data.csv_file_path", "default_data.csv")
    logger.info(f"Application would use data file: {data_file}")

    # TODO: Implement actual application components and flow here
    # (e.g., initializing DataHandler, Strategy, Portfolio, ExecutionHandler, BacktestCoordinator)
    logger.info("Main application logic placeholder finished.")


if __name__ == "__main__":
    # The very first log messages (before setup_logging from config) will use
    # Python's default logging config (usually WARNING to stderr) unless
    # basicConfig is called earlier. We'll call it here with a basic setup
    # just for messages that occur *before* our custom setup_logging is called.
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s
